{Поиск одного решения кубического уравнения методом половинного деления.     }

Program XFunction;
	Uses crt;
	Const
		dx1 = -5; {Границы промежутка}
		dx2 = 5;
		Pgt = 0.000001; {Точность вычислений}
    MaxIt = 100; {Максимальное колличество итераций. Защищает от зацикливания}

	Function f(x :real) :real; {Функция расчета значения уравнения}
	Const
		a = 1;
		b = 5.425;
		c = -2.823;
		d = -33.065;
{ Примерные решения этого уравнения. Получены простым перебором.
F(-4.27) = 0
F(-3.41) = 0
F(2.26) = 0 }
	begin
		f := a*x*x*x+b*x*x+c*x+d; {Ясно?}
	end;

	Procedure Metod1; {Метод половинного деления.}
	Var
  	x :longint;
		Res,Left,Right,Center :real;
	begin
		Left := dx1; {Установка начальных значений границ отрезка и их центра.}
		Right := dx2;
		Center := (dx1+dx2)/2;
    x := 0; {Начальное значение количества итераций}
		repeat
    	inc(x); {Счетчик итераций}
      Res := center; {Будем считать, что рез-тат ур-я - центр промежутка}
      If ((f(left) < 0) and (f(center) > 0))
			or ((f(left) > 0) and (f(center) < 0)) then
      {Если переход графика через ось Х произошол на левой половине
			промежутка, то эта половина станет новым промежутком}
			begin
				right := center;
				center := (left+center)/2;
			end;

      If ((f(right) < 0) and (f(center) > 0))
			or ((f(right) > 0) and (f(center) < 0)) then
      {Если переход графика через ось Х произошол на правой половине
			промежутка, то эта половина станет новым промежутком}
			begin
				left := center;
				center := (right+center)/2;
			end;
{Все это будет продолжаться пока точность ответа не будет меньше точности
решения указанной в константе или колличество итераций цикла не превысит
количесво итераций заданное в константе.}
		Until ((f(res)<Pgt) and (f(res)>-Pgt)) or (x > maxit);

		Writeln('f(',res:0:20,') = ',F(res):0:20); {Напишем ответ}
    Writeln('Число итераций = ',x,', Точность =',Pgt); {И статистику...}
  end;
begin
  clrscr;
  Metod1;
  readkey; {Ну тут все ясно, я думаю...}
end.